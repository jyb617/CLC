# 图构建进度条展示

## 更新内容

为图特征构建过程添加了详细的进度条，让用户可以实时跟踪构建进度。

---

## 新的输出效果

### 完整流程展示

```
Data has been loaded.

================================================================================
Building graph features ...
================================================================================
  [0/3] 构建用户-物品字典...
    处理交互: 100%|████████████████████████| 200000/200000 [00:02<00:00, 95234.12it/s]
  [1/3] 构建用户-物品二部图...
    处理用户: 100%|████████████████████████| 55485/55485 [00:01<00:00, 48521.33it/s]
  [2/3] 构建物品-用户倒排索引...
    索引构建: 100%|████████████████████████| 55485/55485 [00:02<00:00, 23456.78it/s]
  [3/3] 计算用户共现关系...
    共现计算: 100%|████████████████████████| 5986/5986 [00:15<00:00, 387.45it/s]

  ✓ 图构建完成: 200,000 条用户-物品边, 298,754 条用户-用户边
================================================================================
Graph features built successfully!
================================================================================

Initializing model ...
```

---

## 四个阶段说明

### 阶段 0: 构建用户-物品字典
```
[0/3] 构建用户-物品字典...
  处理交互: 100%|████████████████| 200000/200000 [00:02<00:00]
```

**功能**: 遍历所有用户-物品交互记录，构建字典结构
- 输入: 训练数据 (user, item) 对
- 输出: `{user_id: [item_list]}`
- 时间复杂度: O(E), E为交互数量

### 阶段 1: 构建用户-物品二部图
```
[1/3] 构建用户-物品二部图...
  处理用户: 100%|█████████████████| 55485/55485 [00:01<00:00]
```

**功能**: 创建用户→物品和物品→用户的边索引
- 输入: 用户-物品字典
- 输出: `edge_index_ui` 和 `edge_index_iu` 张量
- 时间复杂度: O(N_u), N_u为用户数量

### 阶段 2: 构建物品-用户倒排索引
```
[2/3] 构建物品-用户倒排索引...
  索引构建: 100%|█████████████████| 55485/55485 [00:02<00:00]
```

**功能**: 反向索引，记录每个物品被哪些用户购买
- 输入: 用户-物品字典
- 输出: `{item_id: [user_list]}`
- 时间复杂度: O(E), E为交互数量

### 阶段 3: 计算用户共现关系
```
[3/3] 计算用户共现关系...
  共现计算: 100%|█████████████████| 5986/5986 [00:15<00:00]
```

**功能**: 基于共同购买的物品，计算用户之间的相似关系
- 输入: 物品-用户倒排索引
- 输出: 用户-用户边索引
- 时间复杂度: O(N_i × U_i²), N_i为物品数，U_i为每个物品的用户数
- **注意**: 这是最耗时的阶段

---

## 进度条特性

### 1. 实时速度显示
```
处理交互: 100%|████████| 200000/200000 [00:02<00:00, 95234.12it/s]
                                                       ^^^^^^^^
                                                    每秒处理数量
```

### 2. 剩余时间估计
```
处理用户: 45%|█████     | 25000/55485 [00:01<00:02, 12345.67it/s]
                                           ^^^^^^
                                        预计剩余时间
```

### 3. 百分比和进度条
```
索引构建: 67%|██████▊   | 37000/55485 [00:03<00:01, 10234.56it/s]
           ^^^  ^^^^^^^
         百分比  可视化进度条
```

### 4. 完成统计
```
✓ 图构建完成: 200,000 条用户-物品边, 298,754 条用户-用户边
              ^^^^^^^                 ^^^^^^^
            千位分隔符              千位分隔符
```

---

## 不同数据集的预期时间

### MovieLens (小规模)
```
- 用户数: 55,485
- 物品数: 5,986
- 交互数: 200,000

阶段时间:
  [0/3] ~2秒
  [1/3] ~1秒
  [2/3] ~2秒
  [3/3] ~15秒
总计: ~20秒
```

### TikTok (中等规模)
```
- 用户数: 32,309
- 物品数: 66,456
- 交互数: 726,065

阶段时间:
  [0/3] ~8秒
  [1/3] ~3秒
  [2/3] ~8秒
  [3/3] ~45秒
总计: ~64秒
```

### Amazon (大规模)
```
- 用户数: 27,044
- 物品数: 86,506
- 交互数: 1,689,188

阶段时间:
  [0/3] ~18秒
  [1/3] ~3秒
  [2/3] ~12秒
  [3/3] ~90秒
总计: ~123秒
```

---

## 性能优化提示

### 如果阶段3太慢

**问题**: 用户共现计算是O(N_i × U_i²)复杂度，当某些物品有很多购买用户时会很慢

**解决方案**:

1. **降低min_common_items阈值**
   ```python
   # 在 graph_features.py 中修改
   def _build_user_cooccurrence_graph(self, user_item_dict: Dict,
                                      min_common_items: int = 3):  # 从2改为3
   ```
   - 减少生成的边数量
   - 只保留共同物品较多的用户对

2. **限制最大用户数**
   ```python
   # 对热门物品进行用户采样
   for item, users in tqdm(item_users_dict.items(), desc="    共现计算", ncols=80):
       if len(users) > 100:  # 如果某个物品购买用户太多
           users = random.sample(users, 100)  # 随机采样100个用户
       # ... 原有计算逻辑
   ```

3. **使用更快的数据结构**
   ```python
   # 使用numpy矩阵加速
   import numpy as np
   from scipy.sparse import csr_matrix

   # 构建稀疏矩阵表示
   # 具体实现见高级优化文档
   ```

---

## 进度条配置

### 调整进度条宽度

当前设置: `ncols=80` (80个字符宽)

```python
# 如果终端更宽，可以增大
for user, items in tqdm(user_item_dict.items(), desc="    处理用户", ncols=100):
    ...

# 如果终端较窄，可以减小
for user, items in tqdm(user_item_dict.items(), desc="    处理用户", ncols=60):
    ...
```

### 禁用进度条（非交互环境）

在服务器或日志文件中运行时：

```python
# 添加 disable=True 参数
for user, items in tqdm(user_item_dict.items(), desc="    处理用户", disable=True):
    ...
```

或者通过环境变量：
```bash
export TQDM_DISABLE=1
python main_graph.py --data_path movielens
```

---

## 常见问题

### Q1: 进度条显示不正常？

**A**: 可能是终端不支持ANSI转义序列

解决方案：
```bash
# 方案1: 使用简单模式
export TQDM_ASCII=1
python main_graph.py --data_path movielens

# 方案2: 禁用进度条
export TQDM_DISABLE=1
python main_graph.py --data_path movielens
```

### Q2: 进度条和其他输出混在一起？

**A**: 确保其他print语句不在循环中

错误示例：
```python
for user, items in tqdm(user_item_dict.items()):
    print(f"Processing {user}")  # ❌ 会和进度条混在一起
    ...
```

正确示例：
```python
for user, items in tqdm(user_item_dict.items(), desc="Processing"):
    # ✓ 不在循环内print
    ...
```

### Q3: 阶段3卡住不动？

**A**: 不是卡住，是这个阶段确实很慢

- 对于大数据集，阶段3可能需要几分钟
- 查看 `it/s` 速度，如果不是0就是在正常运行
- 如果速度<10 it/s，考虑优化（见上面的性能优化提示）

### Q4: 想看更详细的进度信息？

**A**: 可以添加更多的子进度条

```python
# 在阶段3的内层循环也添加进度条
for item, users in tqdm(item_users_dict.items(), desc="    共现计算", ncols=80):
    for i, u1 in tqdm(enumerate(users), desc=f"      物品{item}",
                      total=len(users), leave=False):  # leave=False避免重复显示
        for u2 in users[i+1:]:
            ...
```

---

## 技术实现

### 依赖

```python
from tqdm import tqdm  # 进度条库
```

### 基本用法

```python
# 简单循环
for item in tqdm(item_list):
    process(item)

# 带描述
for item in tqdm(item_list, desc="Processing"):
    process(item)

# 自定义宽度
for item in tqdm(item_list, desc="Processing", ncols=80):
    process(item)

# 已知总数
for item in tqdm(item_list, total=len(item_list)):
    process(item)
```

---

## 对比：改进前后

### 改进前
```
Data has been loaded.
Building graph features ...
图构建完成: 200000 条用户-物品边, 298754 条用户-用户边
Graph features built.
```

**问题**:
- ❌ 看不到进度
- ❌ 不知道卡在哪个阶段
- ❌ 不知道需要等多久
- ❌ 大数据集时让人焦虑

### 改进后
```
Data has been loaded.

================================================================================
Building graph features ...
================================================================================
  [0/3] 构建用户-物品字典...
    处理交互: 100%|████████████████████████| 200000/200000 [00:02<00:00, 95234.12it/s]
  [1/3] 构建用户-物品二部图...
    处理用户: 100%|████████████████████████| 55485/55485 [00:01<00:00, 48521.33it/s]
  [2/3] 构建物品-用户倒排索引...
    索引构建: 100%|████████████████████████| 55485/55485 [00:02<00:00, 23456.78it/s]
  [3/3] 计算用户共现关系...
    共现计算: 100%|████████████████████████| 5986/5986 [00:15<00:00, 387.45it/s]

  ✓ 图构建完成: 200,000 条用户-物品边, 298,754 条用户-用户边
================================================================================
Graph features built successfully!
================================================================================
```

**优势**:
- ✅ 实时进度反馈
- ✅ 清楚知道当前阶段
- ✅ 预计剩余时间
- ✅ 处理速度监控
- ✅ 专业的视觉效果

---

## 总结

添加进度条后的改进：

1. **可见性提升**: 用户能实时看到处理进度
2. **信息丰富**: 显示速度、剩余时间、百分比
3. **问题定位**: 容易发现哪个阶段慢
4. **用户体验**: 大幅减少等待焦虑
5. **调试友好**: 便于性能分析和优化

---

**更新日期**: 2025-11-07
**版本**: 1.1.0
**提交**: 58812b4
